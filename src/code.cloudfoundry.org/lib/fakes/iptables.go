// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
)

type IPTables struct {
	ExistsStub        func(table, chain string, rulespec ...string) (bool, error)
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		table    string
		chain    string
		rulespec []string
	}
	existsReturns struct {
		result1 bool
		result2 error
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	InsertStub        func(table, chain string, pos int, rulespec ...string) error
	insertMutex       sync.RWMutex
	insertArgsForCall []struct {
		table    string
		chain    string
		pos      int
		rulespec []string
	}
	insertReturns struct {
		result1 error
	}
	insertReturnsOnCall map[int]struct {
		result1 error
	}
	AppendUniqueStub        func(table, chain string, rulespec ...string) error
	appendUniqueMutex       sync.RWMutex
	appendUniqueArgsForCall []struct {
		table    string
		chain    string
		rulespec []string
	}
	appendUniqueReturns struct {
		result1 error
	}
	appendUniqueReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(table, chain string, rulespec ...string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		table    string
		chain    string
		rulespec []string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	ListStub        func(table, chain string) ([]string, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		table string
		chain string
	}
	listReturns struct {
		result1 []string
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListChainsStub        func(table string) ([]string, error)
	listChainsMutex       sync.RWMutex
	listChainsArgsForCall []struct {
		table string
	}
	listChainsReturns struct {
		result1 []string
		result2 error
	}
	listChainsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	NewChainStub        func(table, chain string) error
	newChainMutex       sync.RWMutex
	newChainArgsForCall []struct {
		table string
		chain string
	}
	newChainReturns struct {
		result1 error
	}
	newChainReturnsOnCall map[int]struct {
		result1 error
	}
	ClearChainStub        func(table, chain string) error
	clearChainMutex       sync.RWMutex
	clearChainArgsForCall []struct {
		table string
		chain string
	}
	clearChainReturns struct {
		result1 error
	}
	clearChainReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteChainStub        func(table, chain string) error
	deleteChainMutex       sync.RWMutex
	deleteChainArgsForCall []struct {
		table string
		chain string
	}
	deleteChainReturns struct {
		result1 error
	}
	deleteChainReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *IPTables) Exists(table string, chain string, rulespec ...string) (bool, error) {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		table    string
		chain    string
		rulespec []string
	}{table, chain, rulespec})
	fake.recordInvocation("Exists", []interface{}{table, chain, rulespec})
	fake.existsMutex.Unlock()
	if fake.ExistsStub != nil {
		return fake.ExistsStub(table, chain, rulespec...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.existsReturns.result1, fake.existsReturns.result2
}

func (fake *IPTables) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *IPTables) ExistsArgsForCall(i int) (string, string, []string) {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return fake.existsArgsForCall[i].table, fake.existsArgsForCall[i].chain, fake.existsArgsForCall[i].rulespec
}

func (fake *IPTables) ExistsReturns(result1 bool, result2 error) {
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *IPTables) ExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *IPTables) Insert(table string, chain string, pos int, rulespec ...string) error {
	fake.insertMutex.Lock()
	ret, specificReturn := fake.insertReturnsOnCall[len(fake.insertArgsForCall)]
	fake.insertArgsForCall = append(fake.insertArgsForCall, struct {
		table    string
		chain    string
		pos      int
		rulespec []string
	}{table, chain, pos, rulespec})
	fake.recordInvocation("Insert", []interface{}{table, chain, pos, rulespec})
	fake.insertMutex.Unlock()
	if fake.InsertStub != nil {
		return fake.InsertStub(table, chain, pos, rulespec...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.insertReturns.result1
}

func (fake *IPTables) InsertCallCount() int {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return len(fake.insertArgsForCall)
}

func (fake *IPTables) InsertArgsForCall(i int) (string, string, int, []string) {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return fake.insertArgsForCall[i].table, fake.insertArgsForCall[i].chain, fake.insertArgsForCall[i].pos, fake.insertArgsForCall[i].rulespec
}

func (fake *IPTables) InsertReturns(result1 error) {
	fake.InsertStub = nil
	fake.insertReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) InsertReturnsOnCall(i int, result1 error) {
	fake.InsertStub = nil
	if fake.insertReturnsOnCall == nil {
		fake.insertReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.insertReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) AppendUnique(table string, chain string, rulespec ...string) error {
	fake.appendUniqueMutex.Lock()
	ret, specificReturn := fake.appendUniqueReturnsOnCall[len(fake.appendUniqueArgsForCall)]
	fake.appendUniqueArgsForCall = append(fake.appendUniqueArgsForCall, struct {
		table    string
		chain    string
		rulespec []string
	}{table, chain, rulespec})
	fake.recordInvocation("AppendUnique", []interface{}{table, chain, rulespec})
	fake.appendUniqueMutex.Unlock()
	if fake.AppendUniqueStub != nil {
		return fake.AppendUniqueStub(table, chain, rulespec...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.appendUniqueReturns.result1
}

func (fake *IPTables) AppendUniqueCallCount() int {
	fake.appendUniqueMutex.RLock()
	defer fake.appendUniqueMutex.RUnlock()
	return len(fake.appendUniqueArgsForCall)
}

func (fake *IPTables) AppendUniqueArgsForCall(i int) (string, string, []string) {
	fake.appendUniqueMutex.RLock()
	defer fake.appendUniqueMutex.RUnlock()
	return fake.appendUniqueArgsForCall[i].table, fake.appendUniqueArgsForCall[i].chain, fake.appendUniqueArgsForCall[i].rulespec
}

func (fake *IPTables) AppendUniqueReturns(result1 error) {
	fake.AppendUniqueStub = nil
	fake.appendUniqueReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) AppendUniqueReturnsOnCall(i int, result1 error) {
	fake.AppendUniqueStub = nil
	if fake.appendUniqueReturnsOnCall == nil {
		fake.appendUniqueReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appendUniqueReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) Delete(table string, chain string, rulespec ...string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		table    string
		chain    string
		rulespec []string
	}{table, chain, rulespec})
	fake.recordInvocation("Delete", []interface{}{table, chain, rulespec})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(table, chain, rulespec...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *IPTables) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *IPTables) DeleteArgsForCall(i int) (string, string, []string) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].table, fake.deleteArgsForCall[i].chain, fake.deleteArgsForCall[i].rulespec
}

func (fake *IPTables) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) List(table string, chain string) ([]string, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("List", []interface{}{table, chain})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(table, chain)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listReturns.result1, fake.listReturns.result2
}

func (fake *IPTables) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *IPTables) ListArgsForCall(i int) (string, string) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].table, fake.listArgsForCall[i].chain
}

func (fake *IPTables) ListReturns(result1 []string, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *IPTables) ListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *IPTables) ListChains(table string) ([]string, error) {
	fake.listChainsMutex.Lock()
	ret, specificReturn := fake.listChainsReturnsOnCall[len(fake.listChainsArgsForCall)]
	fake.listChainsArgsForCall = append(fake.listChainsArgsForCall, struct {
		table string
	}{table})
	fake.recordInvocation("ListChains", []interface{}{table})
	fake.listChainsMutex.Unlock()
	if fake.ListChainsStub != nil {
		return fake.ListChainsStub(table)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listChainsReturns.result1, fake.listChainsReturns.result2
}

func (fake *IPTables) ListChainsCallCount() int {
	fake.listChainsMutex.RLock()
	defer fake.listChainsMutex.RUnlock()
	return len(fake.listChainsArgsForCall)
}

func (fake *IPTables) ListChainsArgsForCall(i int) string {
	fake.listChainsMutex.RLock()
	defer fake.listChainsMutex.RUnlock()
	return fake.listChainsArgsForCall[i].table
}

func (fake *IPTables) ListChainsReturns(result1 []string, result2 error) {
	fake.ListChainsStub = nil
	fake.listChainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *IPTables) ListChainsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.ListChainsStub = nil
	if fake.listChainsReturnsOnCall == nil {
		fake.listChainsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listChainsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *IPTables) NewChain(table string, chain string) error {
	fake.newChainMutex.Lock()
	ret, specificReturn := fake.newChainReturnsOnCall[len(fake.newChainArgsForCall)]
	fake.newChainArgsForCall = append(fake.newChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("NewChain", []interface{}{table, chain})
	fake.newChainMutex.Unlock()
	if fake.NewChainStub != nil {
		return fake.NewChainStub(table, chain)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newChainReturns.result1
}

func (fake *IPTables) NewChainCallCount() int {
	fake.newChainMutex.RLock()
	defer fake.newChainMutex.RUnlock()
	return len(fake.newChainArgsForCall)
}

func (fake *IPTables) NewChainArgsForCall(i int) (string, string) {
	fake.newChainMutex.RLock()
	defer fake.newChainMutex.RUnlock()
	return fake.newChainArgsForCall[i].table, fake.newChainArgsForCall[i].chain
}

func (fake *IPTables) NewChainReturns(result1 error) {
	fake.NewChainStub = nil
	fake.newChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) NewChainReturnsOnCall(i int, result1 error) {
	fake.NewChainStub = nil
	if fake.newChainReturnsOnCall == nil {
		fake.newChainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.newChainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) ClearChain(table string, chain string) error {
	fake.clearChainMutex.Lock()
	ret, specificReturn := fake.clearChainReturnsOnCall[len(fake.clearChainArgsForCall)]
	fake.clearChainArgsForCall = append(fake.clearChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("ClearChain", []interface{}{table, chain})
	fake.clearChainMutex.Unlock()
	if fake.ClearChainStub != nil {
		return fake.ClearChainStub(table, chain)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.clearChainReturns.result1
}

func (fake *IPTables) ClearChainCallCount() int {
	fake.clearChainMutex.RLock()
	defer fake.clearChainMutex.RUnlock()
	return len(fake.clearChainArgsForCall)
}

func (fake *IPTables) ClearChainArgsForCall(i int) (string, string) {
	fake.clearChainMutex.RLock()
	defer fake.clearChainMutex.RUnlock()
	return fake.clearChainArgsForCall[i].table, fake.clearChainArgsForCall[i].chain
}

func (fake *IPTables) ClearChainReturns(result1 error) {
	fake.ClearChainStub = nil
	fake.clearChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) ClearChainReturnsOnCall(i int, result1 error) {
	fake.ClearChainStub = nil
	if fake.clearChainReturnsOnCall == nil {
		fake.clearChainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearChainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) DeleteChain(table string, chain string) error {
	fake.deleteChainMutex.Lock()
	ret, specificReturn := fake.deleteChainReturnsOnCall[len(fake.deleteChainArgsForCall)]
	fake.deleteChainArgsForCall = append(fake.deleteChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("DeleteChain", []interface{}{table, chain})
	fake.deleteChainMutex.Unlock()
	if fake.DeleteChainStub != nil {
		return fake.DeleteChainStub(table, chain)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteChainReturns.result1
}

func (fake *IPTables) DeleteChainCallCount() int {
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	return len(fake.deleteChainArgsForCall)
}

func (fake *IPTables) DeleteChainArgsForCall(i int) (string, string) {
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	return fake.deleteChainArgsForCall[i].table, fake.deleteChainArgsForCall[i].chain
}

func (fake *IPTables) DeleteChainReturns(result1 error) {
	fake.DeleteChainStub = nil
	fake.deleteChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) DeleteChainReturnsOnCall(i int, result1 error) {
	fake.DeleteChainStub = nil
	if fake.deleteChainReturnsOnCall == nil {
		fake.deleteChainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteChainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTables) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	fake.appendUniqueMutex.RLock()
	defer fake.appendUniqueMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.listChainsMutex.RLock()
	defer fake.listChainsMutex.RUnlock()
	fake.newChainMutex.RLock()
	defer fake.newChainMutex.RUnlock()
	fake.clearChainMutex.RLock()
	defer fake.clearChainMutex.RUnlock()
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	return fake.invocations
}

func (fake *IPTables) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
