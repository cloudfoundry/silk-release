// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"code.cloudfoundry.org/lib/rules"
	"sync"
)

type IPTablesAdapter struct {
	ExistsStub        func(table, chain string, rulespec rules.IPTablesRule) (bool, error)
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		table    string
		chain    string
		rulespec rules.IPTablesRule
	}
	existsReturns struct {
		result1 bool
		result2 error
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteStub        func(table, chain string, rulespec rules.IPTablesRule) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		table    string
		chain    string
		rulespec rules.IPTablesRule
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	ListStub        func(table, chain string) ([]string, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		table string
		chain string
	}
	listReturns struct {
		result1 []string
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	NewChainStub        func(table, chain string) error
	newChainMutex       sync.RWMutex
	newChainArgsForCall []struct {
		table string
		chain string
	}
	newChainReturns struct {
		result1 error
	}
	newChainReturnsOnCall map[int]struct {
		result1 error
	}
	ClearChainStub        func(table, chain string) error
	clearChainMutex       sync.RWMutex
	clearChainArgsForCall []struct {
		table string
		chain string
	}
	clearChainReturns struct {
		result1 error
	}
	clearChainReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteChainStub        func(table, chain string) error
	deleteChainMutex       sync.RWMutex
	deleteChainArgsForCall []struct {
		table string
		chain string
	}
	deleteChainReturns struct {
		result1 error
	}
	deleteChainReturnsOnCall map[int]struct {
		result1 error
	}
	BulkInsertStub        func(table, chain string, pos int, rulespec ...rules.IPTablesRule) error
	bulkInsertMutex       sync.RWMutex
	bulkInsertArgsForCall []struct {
		table    string
		chain    string
		pos      int
		rulespec []rules.IPTablesRule
	}
	bulkInsertReturns struct {
		result1 error
	}
	bulkInsertReturnsOnCall map[int]struct {
		result1 error
	}
	BulkAppendStub        func(table, chain string, rulespec ...rules.IPTablesRule) error
	bulkAppendMutex       sync.RWMutex
	bulkAppendArgsForCall []struct {
		table    string
		chain    string
		rulespec []rules.IPTablesRule
	}
	bulkAppendReturns struct {
		result1 error
	}
	bulkAppendReturnsOnCall map[int]struct {
		result1 error
	}
	RuleCountStub        func(table string) (int, error)
	ruleCountMutex       sync.RWMutex
	ruleCountArgsForCall []struct {
		table string
	}
	ruleCountReturns struct {
		result1 int
		result2 error
	}
	ruleCountReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	AllowTrafficForRangeStub        func(rulespec ...rules.IPTablesRule) error
	allowTrafficForRangeMutex       sync.RWMutex
	allowTrafficForRangeArgsForCall []struct {
		rulespec []rules.IPTablesRule
	}
	allowTrafficForRangeReturns struct {
		result1 error
	}
	allowTrafficForRangeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *IPTablesAdapter) Exists(table string, chain string, rulespec rules.IPTablesRule) (bool, error) {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		table    string
		chain    string
		rulespec rules.IPTablesRule
	}{table, chain, rulespec})
	fake.recordInvocation("Exists", []interface{}{table, chain, rulespec})
	fake.existsMutex.Unlock()
	if fake.ExistsStub != nil {
		return fake.ExistsStub(table, chain, rulespec)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.existsReturns.result1, fake.existsReturns.result2
}

func (fake *IPTablesAdapter) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *IPTablesAdapter) ExistsArgsForCall(i int) (string, string, rules.IPTablesRule) {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return fake.existsArgsForCall[i].table, fake.existsArgsForCall[i].chain, fake.existsArgsForCall[i].rulespec
}

func (fake *IPTablesAdapter) ExistsReturns(result1 bool, result2 error) {
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *IPTablesAdapter) ExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *IPTablesAdapter) Delete(table string, chain string, rulespec rules.IPTablesRule) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		table    string
		chain    string
		rulespec rules.IPTablesRule
	}{table, chain, rulespec})
	fake.recordInvocation("Delete", []interface{}{table, chain, rulespec})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(table, chain, rulespec)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *IPTablesAdapter) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *IPTablesAdapter) DeleteArgsForCall(i int) (string, string, rules.IPTablesRule) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].table, fake.deleteArgsForCall[i].chain, fake.deleteArgsForCall[i].rulespec
}

func (fake *IPTablesAdapter) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) List(table string, chain string) ([]string, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("List", []interface{}{table, chain})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(table, chain)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listReturns.result1, fake.listReturns.result2
}

func (fake *IPTablesAdapter) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *IPTablesAdapter) ListArgsForCall(i int) (string, string) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].table, fake.listArgsForCall[i].chain
}

func (fake *IPTablesAdapter) ListReturns(result1 []string, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *IPTablesAdapter) ListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *IPTablesAdapter) NewChain(table string, chain string) error {
	fake.newChainMutex.Lock()
	ret, specificReturn := fake.newChainReturnsOnCall[len(fake.newChainArgsForCall)]
	fake.newChainArgsForCall = append(fake.newChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("NewChain", []interface{}{table, chain})
	fake.newChainMutex.Unlock()
	if fake.NewChainStub != nil {
		return fake.NewChainStub(table, chain)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newChainReturns.result1
}

func (fake *IPTablesAdapter) NewChainCallCount() int {
	fake.newChainMutex.RLock()
	defer fake.newChainMutex.RUnlock()
	return len(fake.newChainArgsForCall)
}

func (fake *IPTablesAdapter) NewChainArgsForCall(i int) (string, string) {
	fake.newChainMutex.RLock()
	defer fake.newChainMutex.RUnlock()
	return fake.newChainArgsForCall[i].table, fake.newChainArgsForCall[i].chain
}

func (fake *IPTablesAdapter) NewChainReturns(result1 error) {
	fake.NewChainStub = nil
	fake.newChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) NewChainReturnsOnCall(i int, result1 error) {
	fake.NewChainStub = nil
	if fake.newChainReturnsOnCall == nil {
		fake.newChainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.newChainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) ClearChain(table string, chain string) error {
	fake.clearChainMutex.Lock()
	ret, specificReturn := fake.clearChainReturnsOnCall[len(fake.clearChainArgsForCall)]
	fake.clearChainArgsForCall = append(fake.clearChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("ClearChain", []interface{}{table, chain})
	fake.clearChainMutex.Unlock()
	if fake.ClearChainStub != nil {
		return fake.ClearChainStub(table, chain)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.clearChainReturns.result1
}

func (fake *IPTablesAdapter) ClearChainCallCount() int {
	fake.clearChainMutex.RLock()
	defer fake.clearChainMutex.RUnlock()
	return len(fake.clearChainArgsForCall)
}

func (fake *IPTablesAdapter) ClearChainArgsForCall(i int) (string, string) {
	fake.clearChainMutex.RLock()
	defer fake.clearChainMutex.RUnlock()
	return fake.clearChainArgsForCall[i].table, fake.clearChainArgsForCall[i].chain
}

func (fake *IPTablesAdapter) ClearChainReturns(result1 error) {
	fake.ClearChainStub = nil
	fake.clearChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) ClearChainReturnsOnCall(i int, result1 error) {
	fake.ClearChainStub = nil
	if fake.clearChainReturnsOnCall == nil {
		fake.clearChainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearChainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) DeleteChain(table string, chain string) error {
	fake.deleteChainMutex.Lock()
	ret, specificReturn := fake.deleteChainReturnsOnCall[len(fake.deleteChainArgsForCall)]
	fake.deleteChainArgsForCall = append(fake.deleteChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("DeleteChain", []interface{}{table, chain})
	fake.deleteChainMutex.Unlock()
	if fake.DeleteChainStub != nil {
		return fake.DeleteChainStub(table, chain)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteChainReturns.result1
}

func (fake *IPTablesAdapter) DeleteChainCallCount() int {
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	return len(fake.deleteChainArgsForCall)
}

func (fake *IPTablesAdapter) DeleteChainArgsForCall(i int) (string, string) {
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	return fake.deleteChainArgsForCall[i].table, fake.deleteChainArgsForCall[i].chain
}

func (fake *IPTablesAdapter) DeleteChainReturns(result1 error) {
	fake.DeleteChainStub = nil
	fake.deleteChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) DeleteChainReturnsOnCall(i int, result1 error) {
	fake.DeleteChainStub = nil
	if fake.deleteChainReturnsOnCall == nil {
		fake.deleteChainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteChainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) BulkInsert(table string, chain string, pos int, rulespec ...rules.IPTablesRule) error {
	fake.bulkInsertMutex.Lock()
	ret, specificReturn := fake.bulkInsertReturnsOnCall[len(fake.bulkInsertArgsForCall)]
	fake.bulkInsertArgsForCall = append(fake.bulkInsertArgsForCall, struct {
		table    string
		chain    string
		pos      int
		rulespec []rules.IPTablesRule
	}{table, chain, pos, rulespec})
	fake.recordInvocation("BulkInsert", []interface{}{table, chain, pos, rulespec})
	fake.bulkInsertMutex.Unlock()
	if fake.BulkInsertStub != nil {
		return fake.BulkInsertStub(table, chain, pos, rulespec...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bulkInsertReturns.result1
}

func (fake *IPTablesAdapter) BulkInsertCallCount() int {
	fake.bulkInsertMutex.RLock()
	defer fake.bulkInsertMutex.RUnlock()
	return len(fake.bulkInsertArgsForCall)
}

func (fake *IPTablesAdapter) BulkInsertArgsForCall(i int) (string, string, int, []rules.IPTablesRule) {
	fake.bulkInsertMutex.RLock()
	defer fake.bulkInsertMutex.RUnlock()
	return fake.bulkInsertArgsForCall[i].table, fake.bulkInsertArgsForCall[i].chain, fake.bulkInsertArgsForCall[i].pos, fake.bulkInsertArgsForCall[i].rulespec
}

func (fake *IPTablesAdapter) BulkInsertReturns(result1 error) {
	fake.BulkInsertStub = nil
	fake.bulkInsertReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) BulkInsertReturnsOnCall(i int, result1 error) {
	fake.BulkInsertStub = nil
	if fake.bulkInsertReturnsOnCall == nil {
		fake.bulkInsertReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bulkInsertReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) BulkAppend(table string, chain string, rulespec ...rules.IPTablesRule) error {
	fake.bulkAppendMutex.Lock()
	ret, specificReturn := fake.bulkAppendReturnsOnCall[len(fake.bulkAppendArgsForCall)]
	fake.bulkAppendArgsForCall = append(fake.bulkAppendArgsForCall, struct {
		table    string
		chain    string
		rulespec []rules.IPTablesRule
	}{table, chain, rulespec})
	fake.recordInvocation("BulkAppend", []interface{}{table, chain, rulespec})
	fake.bulkAppendMutex.Unlock()
	if fake.BulkAppendStub != nil {
		return fake.BulkAppendStub(table, chain, rulespec...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bulkAppendReturns.result1
}

func (fake *IPTablesAdapter) BulkAppendCallCount() int {
	fake.bulkAppendMutex.RLock()
	defer fake.bulkAppendMutex.RUnlock()
	return len(fake.bulkAppendArgsForCall)
}

func (fake *IPTablesAdapter) BulkAppendArgsForCall(i int) (string, string, []rules.IPTablesRule) {
	fake.bulkAppendMutex.RLock()
	defer fake.bulkAppendMutex.RUnlock()
	return fake.bulkAppendArgsForCall[i].table, fake.bulkAppendArgsForCall[i].chain, fake.bulkAppendArgsForCall[i].rulespec
}

func (fake *IPTablesAdapter) BulkAppendReturns(result1 error) {
	fake.BulkAppendStub = nil
	fake.bulkAppendReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) BulkAppendReturnsOnCall(i int, result1 error) {
	fake.BulkAppendStub = nil
	if fake.bulkAppendReturnsOnCall == nil {
		fake.bulkAppendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bulkAppendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) RuleCount(table string) (int, error) {
	fake.ruleCountMutex.Lock()
	ret, specificReturn := fake.ruleCountReturnsOnCall[len(fake.ruleCountArgsForCall)]
	fake.ruleCountArgsForCall = append(fake.ruleCountArgsForCall, struct {
		table string
	}{table})
	fake.recordInvocation("RuleCount", []interface{}{table})
	fake.ruleCountMutex.Unlock()
	if fake.RuleCountStub != nil {
		return fake.RuleCountStub(table)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.ruleCountReturns.result1, fake.ruleCountReturns.result2
}

func (fake *IPTablesAdapter) RuleCountCallCount() int {
	fake.ruleCountMutex.RLock()
	defer fake.ruleCountMutex.RUnlock()
	return len(fake.ruleCountArgsForCall)
}

func (fake *IPTablesAdapter) RuleCountArgsForCall(i int) string {
	fake.ruleCountMutex.RLock()
	defer fake.ruleCountMutex.RUnlock()
	return fake.ruleCountArgsForCall[i].table
}

func (fake *IPTablesAdapter) RuleCountReturns(result1 int, result2 error) {
	fake.RuleCountStub = nil
	fake.ruleCountReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *IPTablesAdapter) RuleCountReturnsOnCall(i int, result1 int, result2 error) {
	fake.RuleCountStub = nil
	if fake.ruleCountReturnsOnCall == nil {
		fake.ruleCountReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.ruleCountReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *IPTablesAdapter) AllowTrafficForRange(rulespec ...rules.IPTablesRule) error {
	fake.allowTrafficForRangeMutex.Lock()
	ret, specificReturn := fake.allowTrafficForRangeReturnsOnCall[len(fake.allowTrafficForRangeArgsForCall)]
	fake.allowTrafficForRangeArgsForCall = append(fake.allowTrafficForRangeArgsForCall, struct {
		rulespec []rules.IPTablesRule
	}{rulespec})
	fake.recordInvocation("AllowTrafficForRange", []interface{}{rulespec})
	fake.allowTrafficForRangeMutex.Unlock()
	if fake.AllowTrafficForRangeStub != nil {
		return fake.AllowTrafficForRangeStub(rulespec...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.allowTrafficForRangeReturns.result1
}

func (fake *IPTablesAdapter) AllowTrafficForRangeCallCount() int {
	fake.allowTrafficForRangeMutex.RLock()
	defer fake.allowTrafficForRangeMutex.RUnlock()
	return len(fake.allowTrafficForRangeArgsForCall)
}

func (fake *IPTablesAdapter) AllowTrafficForRangeArgsForCall(i int) []rules.IPTablesRule {
	fake.allowTrafficForRangeMutex.RLock()
	defer fake.allowTrafficForRangeMutex.RUnlock()
	return fake.allowTrafficForRangeArgsForCall[i].rulespec
}

func (fake *IPTablesAdapter) AllowTrafficForRangeReturns(result1 error) {
	fake.AllowTrafficForRangeStub = nil
	fake.allowTrafficForRangeReturns = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) AllowTrafficForRangeReturnsOnCall(i int, result1 error) {
	fake.AllowTrafficForRangeStub = nil
	if fake.allowTrafficForRangeReturnsOnCall == nil {
		fake.allowTrafficForRangeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.allowTrafficForRangeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IPTablesAdapter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.newChainMutex.RLock()
	defer fake.newChainMutex.RUnlock()
	fake.clearChainMutex.RLock()
	defer fake.clearChainMutex.RUnlock()
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	fake.bulkInsertMutex.RLock()
	defer fake.bulkInsertMutex.RUnlock()
	fake.bulkAppendMutex.RLock()
	defer fake.bulkAppendMutex.RUnlock()
	fake.ruleCountMutex.RLock()
	defer fake.ruleCountMutex.RUnlock()
	fake.allowTrafficForRangeMutex.RLock()
	defer fake.allowTrafficForRangeMutex.RUnlock()
	return fake.invocations
}

func (fake *IPTablesAdapter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rules.IPTablesAdapter = new(IPTablesAdapter)
