// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"code.cloudfoundry.org/silk/controller"
)

type DatabaseHandler struct {
	AddEntryStub        func(controller.Lease) error
	addEntryMutex       sync.RWMutex
	addEntryArgsForCall []struct {
		arg1 controller.Lease
	}
	addEntryReturns struct {
		result1 error
	}
	addEntryReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteEntryStub        func(string) error
	deleteEntryMutex       sync.RWMutex
	deleteEntryArgsForCall []struct {
		arg1 string
	}
	deleteEntryReturns struct {
		result1 error
	}
	deleteEntryReturnsOnCall map[int]struct {
		result1 error
	}
	LeaseForUnderlayIPStub        func(string) (*controller.Lease, error)
	leaseForUnderlayIPMutex       sync.RWMutex
	leaseForUnderlayIPArgsForCall []struct {
		arg1 string
	}
	leaseForUnderlayIPReturns struct {
		result1 *controller.Lease
		result2 error
	}
	leaseForUnderlayIPReturnsOnCall map[int]struct {
		result1 *controller.Lease
		result2 error
	}
	LastRenewedAtForUnderlayIPStub        func(string) (int64, error)
	lastRenewedAtForUnderlayIPMutex       sync.RWMutex
	lastRenewedAtForUnderlayIPArgsForCall []struct {
		arg1 string
	}
	lastRenewedAtForUnderlayIPReturns struct {
		result1 int64
		result2 error
	}
	lastRenewedAtForUnderlayIPReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	RenewLeaseForUnderlayIPStub        func(string) error
	renewLeaseForUnderlayIPMutex       sync.RWMutex
	renewLeaseForUnderlayIPArgsForCall []struct {
		arg1 string
	}
	renewLeaseForUnderlayIPReturns struct {
		result1 error
	}
	renewLeaseForUnderlayIPReturnsOnCall map[int]struct {
		result1 error
	}
	AllStub        func() ([]controller.Lease, error)
	allMutex       sync.RWMutex
	allArgsForCall []struct{}
	allReturns     struct {
		result1 []controller.Lease
		result2 error
	}
	allReturnsOnCall map[int]struct {
		result1 []controller.Lease
		result2 error
	}
	AllBlockSubnetsStub        func() ([]controller.Lease, error)
	allBlockSubnetsMutex       sync.RWMutex
	allBlockSubnetsArgsForCall []struct{}
	allBlockSubnetsReturns     struct {
		result1 []controller.Lease
		result2 error
	}
	allBlockSubnetsReturnsOnCall map[int]struct {
		result1 []controller.Lease
		result2 error
	}
	AllSingleIPSubnetsStub        func() ([]controller.Lease, error)
	allSingleIPSubnetsMutex       sync.RWMutex
	allSingleIPSubnetsArgsForCall []struct{}
	allSingleIPSubnetsReturns     struct {
		result1 []controller.Lease
		result2 error
	}
	allSingleIPSubnetsReturnsOnCall map[int]struct {
		result1 []controller.Lease
		result2 error
	}
	AllActiveStub        func(int) ([]controller.Lease, error)
	allActiveMutex       sync.RWMutex
	allActiveArgsForCall []struct {
		arg1 int
	}
	allActiveReturns struct {
		result1 []controller.Lease
		result2 error
	}
	allActiveReturnsOnCall map[int]struct {
		result1 []controller.Lease
		result2 error
	}
	OldestExpiredBlockSubnetStub        func(int) (*controller.Lease, error)
	oldestExpiredBlockSubnetMutex       sync.RWMutex
	oldestExpiredBlockSubnetArgsForCall []struct {
		arg1 int
	}
	oldestExpiredBlockSubnetReturns struct {
		result1 *controller.Lease
		result2 error
	}
	oldestExpiredBlockSubnetReturnsOnCall map[int]struct {
		result1 *controller.Lease
		result2 error
	}
	OldestExpiredSingleIPStub        func(int) (*controller.Lease, error)
	oldestExpiredSingleIPMutex       sync.RWMutex
	oldestExpiredSingleIPArgsForCall []struct {
		arg1 int
	}
	oldestExpiredSingleIPReturns struct {
		result1 *controller.Lease
		result2 error
	}
	oldestExpiredSingleIPReturnsOnCall map[int]struct {
		result1 *controller.Lease
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *DatabaseHandler) AddEntry(arg1 controller.Lease) error {
	fake.addEntryMutex.Lock()
	ret, specificReturn := fake.addEntryReturnsOnCall[len(fake.addEntryArgsForCall)]
	fake.addEntryArgsForCall = append(fake.addEntryArgsForCall, struct {
		arg1 controller.Lease
	}{arg1})
	fake.recordInvocation("AddEntry", []interface{}{arg1})
	fake.addEntryMutex.Unlock()
	if fake.AddEntryStub != nil {
		return fake.AddEntryStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addEntryReturns.result1
}

func (fake *DatabaseHandler) AddEntryCallCount() int {
	fake.addEntryMutex.RLock()
	defer fake.addEntryMutex.RUnlock()
	return len(fake.addEntryArgsForCall)
}

func (fake *DatabaseHandler) AddEntryArgsForCall(i int) controller.Lease {
	fake.addEntryMutex.RLock()
	defer fake.addEntryMutex.RUnlock()
	return fake.addEntryArgsForCall[i].arg1
}

func (fake *DatabaseHandler) AddEntryReturns(result1 error) {
	fake.AddEntryStub = nil
	fake.addEntryReturns = struct {
		result1 error
	}{result1}
}

func (fake *DatabaseHandler) AddEntryReturnsOnCall(i int, result1 error) {
	fake.AddEntryStub = nil
	if fake.addEntryReturnsOnCall == nil {
		fake.addEntryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addEntryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *DatabaseHandler) DeleteEntry(arg1 string) error {
	fake.deleteEntryMutex.Lock()
	ret, specificReturn := fake.deleteEntryReturnsOnCall[len(fake.deleteEntryArgsForCall)]
	fake.deleteEntryArgsForCall = append(fake.deleteEntryArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteEntry", []interface{}{arg1})
	fake.deleteEntryMutex.Unlock()
	if fake.DeleteEntryStub != nil {
		return fake.DeleteEntryStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteEntryReturns.result1
}

func (fake *DatabaseHandler) DeleteEntryCallCount() int {
	fake.deleteEntryMutex.RLock()
	defer fake.deleteEntryMutex.RUnlock()
	return len(fake.deleteEntryArgsForCall)
}

func (fake *DatabaseHandler) DeleteEntryArgsForCall(i int) string {
	fake.deleteEntryMutex.RLock()
	defer fake.deleteEntryMutex.RUnlock()
	return fake.deleteEntryArgsForCall[i].arg1
}

func (fake *DatabaseHandler) DeleteEntryReturns(result1 error) {
	fake.DeleteEntryStub = nil
	fake.deleteEntryReturns = struct {
		result1 error
	}{result1}
}

func (fake *DatabaseHandler) DeleteEntryReturnsOnCall(i int, result1 error) {
	fake.DeleteEntryStub = nil
	if fake.deleteEntryReturnsOnCall == nil {
		fake.deleteEntryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteEntryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *DatabaseHandler) LeaseForUnderlayIP(arg1 string) (*controller.Lease, error) {
	fake.leaseForUnderlayIPMutex.Lock()
	ret, specificReturn := fake.leaseForUnderlayIPReturnsOnCall[len(fake.leaseForUnderlayIPArgsForCall)]
	fake.leaseForUnderlayIPArgsForCall = append(fake.leaseForUnderlayIPArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("LeaseForUnderlayIP", []interface{}{arg1})
	fake.leaseForUnderlayIPMutex.Unlock()
	if fake.LeaseForUnderlayIPStub != nil {
		return fake.LeaseForUnderlayIPStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.leaseForUnderlayIPReturns.result1, fake.leaseForUnderlayIPReturns.result2
}

func (fake *DatabaseHandler) LeaseForUnderlayIPCallCount() int {
	fake.leaseForUnderlayIPMutex.RLock()
	defer fake.leaseForUnderlayIPMutex.RUnlock()
	return len(fake.leaseForUnderlayIPArgsForCall)
}

func (fake *DatabaseHandler) LeaseForUnderlayIPArgsForCall(i int) string {
	fake.leaseForUnderlayIPMutex.RLock()
	defer fake.leaseForUnderlayIPMutex.RUnlock()
	return fake.leaseForUnderlayIPArgsForCall[i].arg1
}

func (fake *DatabaseHandler) LeaseForUnderlayIPReturns(result1 *controller.Lease, result2 error) {
	fake.LeaseForUnderlayIPStub = nil
	fake.leaseForUnderlayIPReturns = struct {
		result1 *controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) LeaseForUnderlayIPReturnsOnCall(i int, result1 *controller.Lease, result2 error) {
	fake.LeaseForUnderlayIPStub = nil
	if fake.leaseForUnderlayIPReturnsOnCall == nil {
		fake.leaseForUnderlayIPReturnsOnCall = make(map[int]struct {
			result1 *controller.Lease
			result2 error
		})
	}
	fake.leaseForUnderlayIPReturnsOnCall[i] = struct {
		result1 *controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) LastRenewedAtForUnderlayIP(arg1 string) (int64, error) {
	fake.lastRenewedAtForUnderlayIPMutex.Lock()
	ret, specificReturn := fake.lastRenewedAtForUnderlayIPReturnsOnCall[len(fake.lastRenewedAtForUnderlayIPArgsForCall)]
	fake.lastRenewedAtForUnderlayIPArgsForCall = append(fake.lastRenewedAtForUnderlayIPArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("LastRenewedAtForUnderlayIP", []interface{}{arg1})
	fake.lastRenewedAtForUnderlayIPMutex.Unlock()
	if fake.LastRenewedAtForUnderlayIPStub != nil {
		return fake.LastRenewedAtForUnderlayIPStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.lastRenewedAtForUnderlayIPReturns.result1, fake.lastRenewedAtForUnderlayIPReturns.result2
}

func (fake *DatabaseHandler) LastRenewedAtForUnderlayIPCallCount() int {
	fake.lastRenewedAtForUnderlayIPMutex.RLock()
	defer fake.lastRenewedAtForUnderlayIPMutex.RUnlock()
	return len(fake.lastRenewedAtForUnderlayIPArgsForCall)
}

func (fake *DatabaseHandler) LastRenewedAtForUnderlayIPArgsForCall(i int) string {
	fake.lastRenewedAtForUnderlayIPMutex.RLock()
	defer fake.lastRenewedAtForUnderlayIPMutex.RUnlock()
	return fake.lastRenewedAtForUnderlayIPArgsForCall[i].arg1
}

func (fake *DatabaseHandler) LastRenewedAtForUnderlayIPReturns(result1 int64, result2 error) {
	fake.LastRenewedAtForUnderlayIPStub = nil
	fake.lastRenewedAtForUnderlayIPReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) LastRenewedAtForUnderlayIPReturnsOnCall(i int, result1 int64, result2 error) {
	fake.LastRenewedAtForUnderlayIPStub = nil
	if fake.lastRenewedAtForUnderlayIPReturnsOnCall == nil {
		fake.lastRenewedAtForUnderlayIPReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.lastRenewedAtForUnderlayIPReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) RenewLeaseForUnderlayIP(arg1 string) error {
	fake.renewLeaseForUnderlayIPMutex.Lock()
	ret, specificReturn := fake.renewLeaseForUnderlayIPReturnsOnCall[len(fake.renewLeaseForUnderlayIPArgsForCall)]
	fake.renewLeaseForUnderlayIPArgsForCall = append(fake.renewLeaseForUnderlayIPArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RenewLeaseForUnderlayIP", []interface{}{arg1})
	fake.renewLeaseForUnderlayIPMutex.Unlock()
	if fake.RenewLeaseForUnderlayIPStub != nil {
		return fake.RenewLeaseForUnderlayIPStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renewLeaseForUnderlayIPReturns.result1
}

func (fake *DatabaseHandler) RenewLeaseForUnderlayIPCallCount() int {
	fake.renewLeaseForUnderlayIPMutex.RLock()
	defer fake.renewLeaseForUnderlayIPMutex.RUnlock()
	return len(fake.renewLeaseForUnderlayIPArgsForCall)
}

func (fake *DatabaseHandler) RenewLeaseForUnderlayIPArgsForCall(i int) string {
	fake.renewLeaseForUnderlayIPMutex.RLock()
	defer fake.renewLeaseForUnderlayIPMutex.RUnlock()
	return fake.renewLeaseForUnderlayIPArgsForCall[i].arg1
}

func (fake *DatabaseHandler) RenewLeaseForUnderlayIPReturns(result1 error) {
	fake.RenewLeaseForUnderlayIPStub = nil
	fake.renewLeaseForUnderlayIPReturns = struct {
		result1 error
	}{result1}
}

func (fake *DatabaseHandler) RenewLeaseForUnderlayIPReturnsOnCall(i int, result1 error) {
	fake.RenewLeaseForUnderlayIPStub = nil
	if fake.renewLeaseForUnderlayIPReturnsOnCall == nil {
		fake.renewLeaseForUnderlayIPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renewLeaseForUnderlayIPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *DatabaseHandler) All() ([]controller.Lease, error) {
	fake.allMutex.Lock()
	ret, specificReturn := fake.allReturnsOnCall[len(fake.allArgsForCall)]
	fake.allArgsForCall = append(fake.allArgsForCall, struct{}{})
	fake.recordInvocation("All", []interface{}{})
	fake.allMutex.Unlock()
	if fake.AllStub != nil {
		return fake.AllStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.allReturns.result1, fake.allReturns.result2
}

func (fake *DatabaseHandler) AllCallCount() int {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	return len(fake.allArgsForCall)
}

func (fake *DatabaseHandler) AllReturns(result1 []controller.Lease, result2 error) {
	fake.AllStub = nil
	fake.allReturns = struct {
		result1 []controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) AllReturnsOnCall(i int, result1 []controller.Lease, result2 error) {
	fake.AllStub = nil
	if fake.allReturnsOnCall == nil {
		fake.allReturnsOnCall = make(map[int]struct {
			result1 []controller.Lease
			result2 error
		})
	}
	fake.allReturnsOnCall[i] = struct {
		result1 []controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) AllBlockSubnets() ([]controller.Lease, error) {
	fake.allBlockSubnetsMutex.Lock()
	ret, specificReturn := fake.allBlockSubnetsReturnsOnCall[len(fake.allBlockSubnetsArgsForCall)]
	fake.allBlockSubnetsArgsForCall = append(fake.allBlockSubnetsArgsForCall, struct{}{})
	fake.recordInvocation("AllBlockSubnets", []interface{}{})
	fake.allBlockSubnetsMutex.Unlock()
	if fake.AllBlockSubnetsStub != nil {
		return fake.AllBlockSubnetsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.allBlockSubnetsReturns.result1, fake.allBlockSubnetsReturns.result2
}

func (fake *DatabaseHandler) AllBlockSubnetsCallCount() int {
	fake.allBlockSubnetsMutex.RLock()
	defer fake.allBlockSubnetsMutex.RUnlock()
	return len(fake.allBlockSubnetsArgsForCall)
}

func (fake *DatabaseHandler) AllBlockSubnetsReturns(result1 []controller.Lease, result2 error) {
	fake.AllBlockSubnetsStub = nil
	fake.allBlockSubnetsReturns = struct {
		result1 []controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) AllBlockSubnetsReturnsOnCall(i int, result1 []controller.Lease, result2 error) {
	fake.AllBlockSubnetsStub = nil
	if fake.allBlockSubnetsReturnsOnCall == nil {
		fake.allBlockSubnetsReturnsOnCall = make(map[int]struct {
			result1 []controller.Lease
			result2 error
		})
	}
	fake.allBlockSubnetsReturnsOnCall[i] = struct {
		result1 []controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) AllSingleIPSubnets() ([]controller.Lease, error) {
	fake.allSingleIPSubnetsMutex.Lock()
	ret, specificReturn := fake.allSingleIPSubnetsReturnsOnCall[len(fake.allSingleIPSubnetsArgsForCall)]
	fake.allSingleIPSubnetsArgsForCall = append(fake.allSingleIPSubnetsArgsForCall, struct{}{})
	fake.recordInvocation("AllSingleIPSubnets", []interface{}{})
	fake.allSingleIPSubnetsMutex.Unlock()
	if fake.AllSingleIPSubnetsStub != nil {
		return fake.AllSingleIPSubnetsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.allSingleIPSubnetsReturns.result1, fake.allSingleIPSubnetsReturns.result2
}

func (fake *DatabaseHandler) AllSingleIPSubnetsCallCount() int {
	fake.allSingleIPSubnetsMutex.RLock()
	defer fake.allSingleIPSubnetsMutex.RUnlock()
	return len(fake.allSingleIPSubnetsArgsForCall)
}

func (fake *DatabaseHandler) AllSingleIPSubnetsReturns(result1 []controller.Lease, result2 error) {
	fake.AllSingleIPSubnetsStub = nil
	fake.allSingleIPSubnetsReturns = struct {
		result1 []controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) AllSingleIPSubnetsReturnsOnCall(i int, result1 []controller.Lease, result2 error) {
	fake.AllSingleIPSubnetsStub = nil
	if fake.allSingleIPSubnetsReturnsOnCall == nil {
		fake.allSingleIPSubnetsReturnsOnCall = make(map[int]struct {
			result1 []controller.Lease
			result2 error
		})
	}
	fake.allSingleIPSubnetsReturnsOnCall[i] = struct {
		result1 []controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) AllActive(arg1 int) ([]controller.Lease, error) {
	fake.allActiveMutex.Lock()
	ret, specificReturn := fake.allActiveReturnsOnCall[len(fake.allActiveArgsForCall)]
	fake.allActiveArgsForCall = append(fake.allActiveArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("AllActive", []interface{}{arg1})
	fake.allActiveMutex.Unlock()
	if fake.AllActiveStub != nil {
		return fake.AllActiveStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.allActiveReturns.result1, fake.allActiveReturns.result2
}

func (fake *DatabaseHandler) AllActiveCallCount() int {
	fake.allActiveMutex.RLock()
	defer fake.allActiveMutex.RUnlock()
	return len(fake.allActiveArgsForCall)
}

func (fake *DatabaseHandler) AllActiveArgsForCall(i int) int {
	fake.allActiveMutex.RLock()
	defer fake.allActiveMutex.RUnlock()
	return fake.allActiveArgsForCall[i].arg1
}

func (fake *DatabaseHandler) AllActiveReturns(result1 []controller.Lease, result2 error) {
	fake.AllActiveStub = nil
	fake.allActiveReturns = struct {
		result1 []controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) AllActiveReturnsOnCall(i int, result1 []controller.Lease, result2 error) {
	fake.AllActiveStub = nil
	if fake.allActiveReturnsOnCall == nil {
		fake.allActiveReturnsOnCall = make(map[int]struct {
			result1 []controller.Lease
			result2 error
		})
	}
	fake.allActiveReturnsOnCall[i] = struct {
		result1 []controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) OldestExpiredBlockSubnet(arg1 int) (*controller.Lease, error) {
	fake.oldestExpiredBlockSubnetMutex.Lock()
	ret, specificReturn := fake.oldestExpiredBlockSubnetReturnsOnCall[len(fake.oldestExpiredBlockSubnetArgsForCall)]
	fake.oldestExpiredBlockSubnetArgsForCall = append(fake.oldestExpiredBlockSubnetArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("OldestExpiredBlockSubnet", []interface{}{arg1})
	fake.oldestExpiredBlockSubnetMutex.Unlock()
	if fake.OldestExpiredBlockSubnetStub != nil {
		return fake.OldestExpiredBlockSubnetStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.oldestExpiredBlockSubnetReturns.result1, fake.oldestExpiredBlockSubnetReturns.result2
}

func (fake *DatabaseHandler) OldestExpiredBlockSubnetCallCount() int {
	fake.oldestExpiredBlockSubnetMutex.RLock()
	defer fake.oldestExpiredBlockSubnetMutex.RUnlock()
	return len(fake.oldestExpiredBlockSubnetArgsForCall)
}

func (fake *DatabaseHandler) OldestExpiredBlockSubnetArgsForCall(i int) int {
	fake.oldestExpiredBlockSubnetMutex.RLock()
	defer fake.oldestExpiredBlockSubnetMutex.RUnlock()
	return fake.oldestExpiredBlockSubnetArgsForCall[i].arg1
}

func (fake *DatabaseHandler) OldestExpiredBlockSubnetReturns(result1 *controller.Lease, result2 error) {
	fake.OldestExpiredBlockSubnetStub = nil
	fake.oldestExpiredBlockSubnetReturns = struct {
		result1 *controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) OldestExpiredBlockSubnetReturnsOnCall(i int, result1 *controller.Lease, result2 error) {
	fake.OldestExpiredBlockSubnetStub = nil
	if fake.oldestExpiredBlockSubnetReturnsOnCall == nil {
		fake.oldestExpiredBlockSubnetReturnsOnCall = make(map[int]struct {
			result1 *controller.Lease
			result2 error
		})
	}
	fake.oldestExpiredBlockSubnetReturnsOnCall[i] = struct {
		result1 *controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) OldestExpiredSingleIP(arg1 int) (*controller.Lease, error) {
	fake.oldestExpiredSingleIPMutex.Lock()
	ret, specificReturn := fake.oldestExpiredSingleIPReturnsOnCall[len(fake.oldestExpiredSingleIPArgsForCall)]
	fake.oldestExpiredSingleIPArgsForCall = append(fake.oldestExpiredSingleIPArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("OldestExpiredSingleIP", []interface{}{arg1})
	fake.oldestExpiredSingleIPMutex.Unlock()
	if fake.OldestExpiredSingleIPStub != nil {
		return fake.OldestExpiredSingleIPStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.oldestExpiredSingleIPReturns.result1, fake.oldestExpiredSingleIPReturns.result2
}

func (fake *DatabaseHandler) OldestExpiredSingleIPCallCount() int {
	fake.oldestExpiredSingleIPMutex.RLock()
	defer fake.oldestExpiredSingleIPMutex.RUnlock()
	return len(fake.oldestExpiredSingleIPArgsForCall)
}

func (fake *DatabaseHandler) OldestExpiredSingleIPArgsForCall(i int) int {
	fake.oldestExpiredSingleIPMutex.RLock()
	defer fake.oldestExpiredSingleIPMutex.RUnlock()
	return fake.oldestExpiredSingleIPArgsForCall[i].arg1
}

func (fake *DatabaseHandler) OldestExpiredSingleIPReturns(result1 *controller.Lease, result2 error) {
	fake.OldestExpiredSingleIPStub = nil
	fake.oldestExpiredSingleIPReturns = struct {
		result1 *controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) OldestExpiredSingleIPReturnsOnCall(i int, result1 *controller.Lease, result2 error) {
	fake.OldestExpiredSingleIPStub = nil
	if fake.oldestExpiredSingleIPReturnsOnCall == nil {
		fake.oldestExpiredSingleIPReturnsOnCall = make(map[int]struct {
			result1 *controller.Lease
			result2 error
		})
	}
	fake.oldestExpiredSingleIPReturnsOnCall[i] = struct {
		result1 *controller.Lease
		result2 error
	}{result1, result2}
}

func (fake *DatabaseHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addEntryMutex.RLock()
	defer fake.addEntryMutex.RUnlock()
	fake.deleteEntryMutex.RLock()
	defer fake.deleteEntryMutex.RUnlock()
	fake.leaseForUnderlayIPMutex.RLock()
	defer fake.leaseForUnderlayIPMutex.RUnlock()
	fake.lastRenewedAtForUnderlayIPMutex.RLock()
	defer fake.lastRenewedAtForUnderlayIPMutex.RUnlock()
	fake.renewLeaseForUnderlayIPMutex.RLock()
	defer fake.renewLeaseForUnderlayIPMutex.RUnlock()
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	fake.allBlockSubnetsMutex.RLock()
	defer fake.allBlockSubnetsMutex.RUnlock()
	fake.allSingleIPSubnetsMutex.RLock()
	defer fake.allSingleIPSubnetsMutex.RUnlock()
	fake.allActiveMutex.RLock()
	defer fake.allActiveMutex.RUnlock()
	fake.oldestExpiredBlockSubnetMutex.RLock()
	defer fake.oldestExpiredBlockSubnetMutex.RUnlock()
	fake.oldestExpiredSingleIPMutex.RLock()
	defer fake.oldestExpiredSingleIPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *DatabaseHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
