// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"net"
	"sync"

	"github.com/containernetworking/cni/pkg/types"
	"github.com/vishvananda/netlink"
)

type LinkOperations struct {
	DeleteLinkByNameStub        func(string) error
	deleteLinkByNameMutex       sync.RWMutex
	deleteLinkByNameArgsForCall []struct {
		arg1 string
	}
	deleteLinkByNameReturns struct {
		result1 error
	}
	deleteLinkByNameReturnsOnCall map[int]struct {
		result1 error
	}
	DisableIPv6Stub        func(string) error
	disableIPv6Mutex       sync.RWMutex
	disableIPv6ArgsForCall []struct {
		arg1 string
	}
	disableIPv6Returns struct {
		result1 error
	}
	disableIPv6ReturnsOnCall map[int]struct {
		result1 error
	}
	EnableIPv4ForwardingStub        func() error
	enableIPv4ForwardingMutex       sync.RWMutex
	enableIPv4ForwardingArgsForCall []struct {
	}
	enableIPv4ForwardingReturns struct {
		result1 error
	}
	enableIPv4ForwardingReturnsOnCall map[int]struct {
		result1 error
	}
	EnableReversePathFilteringStub        func(string) error
	enableReversePathFilteringMutex       sync.RWMutex
	enableReversePathFilteringArgsForCall []struct {
		arg1 string
	}
	enableReversePathFilteringReturns struct {
		result1 error
	}
	enableReversePathFilteringReturnsOnCall map[int]struct {
		result1 error
	}
	RenameLinkStub        func(string, string) error
	renameLinkMutex       sync.RWMutex
	renameLinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameLinkReturns struct {
		result1 error
	}
	renameLinkReturnsOnCall map[int]struct {
		result1 error
	}
	RouteAddAllStub        func([]*types.Route, net.IP) error
	routeAddAllMutex       sync.RWMutex
	routeAddAllArgsForCall []struct {
		arg1 []*types.Route
		arg2 net.IP
	}
	routeAddAllReturns struct {
		result1 error
	}
	routeAddAllReturnsOnCall map[int]struct {
		result1 error
	}
	SetPointToPointAddressStub        func(netlink.Link, net.IP, net.IP) error
	setPointToPointAddressMutex       sync.RWMutex
	setPointToPointAddressArgsForCall []struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.IP
	}
	setPointToPointAddressReturns struct {
		result1 error
	}
	setPointToPointAddressReturnsOnCall map[int]struct {
		result1 error
	}
	StaticNeighborNoARPStub        func(netlink.Link, net.IP, net.HardwareAddr) error
	staticNeighborNoARPMutex       sync.RWMutex
	staticNeighborNoARPArgsForCall []struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.HardwareAddr
	}
	staticNeighborNoARPReturns struct {
		result1 error
	}
	staticNeighborNoARPReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *LinkOperations) DeleteLinkByName(arg1 string) error {
	fake.deleteLinkByNameMutex.Lock()
	ret, specificReturn := fake.deleteLinkByNameReturnsOnCall[len(fake.deleteLinkByNameArgsForCall)]
	fake.deleteLinkByNameArgsForCall = append(fake.deleteLinkByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteLinkByNameStub
	fakeReturns := fake.deleteLinkByNameReturns
	fake.recordInvocation("DeleteLinkByName", []interface{}{arg1})
	fake.deleteLinkByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) DeleteLinkByNameCallCount() int {
	fake.deleteLinkByNameMutex.RLock()
	defer fake.deleteLinkByNameMutex.RUnlock()
	return len(fake.deleteLinkByNameArgsForCall)
}

func (fake *LinkOperations) DeleteLinkByNameCalls(stub func(string) error) {
	fake.deleteLinkByNameMutex.Lock()
	defer fake.deleteLinkByNameMutex.Unlock()
	fake.DeleteLinkByNameStub = stub
}

func (fake *LinkOperations) DeleteLinkByNameArgsForCall(i int) string {
	fake.deleteLinkByNameMutex.RLock()
	defer fake.deleteLinkByNameMutex.RUnlock()
	argsForCall := fake.deleteLinkByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *LinkOperations) DeleteLinkByNameReturns(result1 error) {
	fake.deleteLinkByNameMutex.Lock()
	defer fake.deleteLinkByNameMutex.Unlock()
	fake.DeleteLinkByNameStub = nil
	fake.deleteLinkByNameReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) DeleteLinkByNameReturnsOnCall(i int, result1 error) {
	fake.deleteLinkByNameMutex.Lock()
	defer fake.deleteLinkByNameMutex.Unlock()
	fake.DeleteLinkByNameStub = nil
	if fake.deleteLinkByNameReturnsOnCall == nil {
		fake.deleteLinkByNameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteLinkByNameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) DisableIPv6(arg1 string) error {
	fake.disableIPv6Mutex.Lock()
	ret, specificReturn := fake.disableIPv6ReturnsOnCall[len(fake.disableIPv6ArgsForCall)]
	fake.disableIPv6ArgsForCall = append(fake.disableIPv6ArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DisableIPv6Stub
	fakeReturns := fake.disableIPv6Returns
	fake.recordInvocation("DisableIPv6", []interface{}{arg1})
	fake.disableIPv6Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) DisableIPv6CallCount() int {
	fake.disableIPv6Mutex.RLock()
	defer fake.disableIPv6Mutex.RUnlock()
	return len(fake.disableIPv6ArgsForCall)
}

func (fake *LinkOperations) DisableIPv6Calls(stub func(string) error) {
	fake.disableIPv6Mutex.Lock()
	defer fake.disableIPv6Mutex.Unlock()
	fake.DisableIPv6Stub = stub
}

func (fake *LinkOperations) DisableIPv6ArgsForCall(i int) string {
	fake.disableIPv6Mutex.RLock()
	defer fake.disableIPv6Mutex.RUnlock()
	argsForCall := fake.disableIPv6ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *LinkOperations) DisableIPv6Returns(result1 error) {
	fake.disableIPv6Mutex.Lock()
	defer fake.disableIPv6Mutex.Unlock()
	fake.DisableIPv6Stub = nil
	fake.disableIPv6Returns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) DisableIPv6ReturnsOnCall(i int, result1 error) {
	fake.disableIPv6Mutex.Lock()
	defer fake.disableIPv6Mutex.Unlock()
	fake.DisableIPv6Stub = nil
	if fake.disableIPv6ReturnsOnCall == nil {
		fake.disableIPv6ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disableIPv6ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableIPv4Forwarding() error {
	fake.enableIPv4ForwardingMutex.Lock()
	ret, specificReturn := fake.enableIPv4ForwardingReturnsOnCall[len(fake.enableIPv4ForwardingArgsForCall)]
	fake.enableIPv4ForwardingArgsForCall = append(fake.enableIPv4ForwardingArgsForCall, struct {
	}{})
	stub := fake.EnableIPv4ForwardingStub
	fakeReturns := fake.enableIPv4ForwardingReturns
	fake.recordInvocation("EnableIPv4Forwarding", []interface{}{})
	fake.enableIPv4ForwardingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) EnableIPv4ForwardingCallCount() int {
	fake.enableIPv4ForwardingMutex.RLock()
	defer fake.enableIPv4ForwardingMutex.RUnlock()
	return len(fake.enableIPv4ForwardingArgsForCall)
}

func (fake *LinkOperations) EnableIPv4ForwardingCalls(stub func() error) {
	fake.enableIPv4ForwardingMutex.Lock()
	defer fake.enableIPv4ForwardingMutex.Unlock()
	fake.EnableIPv4ForwardingStub = stub
}

func (fake *LinkOperations) EnableIPv4ForwardingReturns(result1 error) {
	fake.enableIPv4ForwardingMutex.Lock()
	defer fake.enableIPv4ForwardingMutex.Unlock()
	fake.EnableIPv4ForwardingStub = nil
	fake.enableIPv4ForwardingReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableIPv4ForwardingReturnsOnCall(i int, result1 error) {
	fake.enableIPv4ForwardingMutex.Lock()
	defer fake.enableIPv4ForwardingMutex.Unlock()
	fake.EnableIPv4ForwardingStub = nil
	if fake.enableIPv4ForwardingReturnsOnCall == nil {
		fake.enableIPv4ForwardingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableIPv4ForwardingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableReversePathFiltering(arg1 string) error {
	fake.enableReversePathFilteringMutex.Lock()
	ret, specificReturn := fake.enableReversePathFilteringReturnsOnCall[len(fake.enableReversePathFilteringArgsForCall)]
	fake.enableReversePathFilteringArgsForCall = append(fake.enableReversePathFilteringArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EnableReversePathFilteringStub
	fakeReturns := fake.enableReversePathFilteringReturns
	fake.recordInvocation("EnableReversePathFiltering", []interface{}{arg1})
	fake.enableReversePathFilteringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) EnableReversePathFilteringCallCount() int {
	fake.enableReversePathFilteringMutex.RLock()
	defer fake.enableReversePathFilteringMutex.RUnlock()
	return len(fake.enableReversePathFilteringArgsForCall)
}

func (fake *LinkOperations) EnableReversePathFilteringCalls(stub func(string) error) {
	fake.enableReversePathFilteringMutex.Lock()
	defer fake.enableReversePathFilteringMutex.Unlock()
	fake.EnableReversePathFilteringStub = stub
}

func (fake *LinkOperations) EnableReversePathFilteringArgsForCall(i int) string {
	fake.enableReversePathFilteringMutex.RLock()
	defer fake.enableReversePathFilteringMutex.RUnlock()
	argsForCall := fake.enableReversePathFilteringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *LinkOperations) EnableReversePathFilteringReturns(result1 error) {
	fake.enableReversePathFilteringMutex.Lock()
	defer fake.enableReversePathFilteringMutex.Unlock()
	fake.EnableReversePathFilteringStub = nil
	fake.enableReversePathFilteringReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableReversePathFilteringReturnsOnCall(i int, result1 error) {
	fake.enableReversePathFilteringMutex.Lock()
	defer fake.enableReversePathFilteringMutex.Unlock()
	fake.EnableReversePathFilteringStub = nil
	if fake.enableReversePathFilteringReturnsOnCall == nil {
		fake.enableReversePathFilteringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableReversePathFilteringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) RenameLink(arg1 string, arg2 string) error {
	fake.renameLinkMutex.Lock()
	ret, specificReturn := fake.renameLinkReturnsOnCall[len(fake.renameLinkArgsForCall)]
	fake.renameLinkArgsForCall = append(fake.renameLinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameLinkStub
	fakeReturns := fake.renameLinkReturns
	fake.recordInvocation("RenameLink", []interface{}{arg1, arg2})
	fake.renameLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) RenameLinkCallCount() int {
	fake.renameLinkMutex.RLock()
	defer fake.renameLinkMutex.RUnlock()
	return len(fake.renameLinkArgsForCall)
}

func (fake *LinkOperations) RenameLinkCalls(stub func(string, string) error) {
	fake.renameLinkMutex.Lock()
	defer fake.renameLinkMutex.Unlock()
	fake.RenameLinkStub = stub
}

func (fake *LinkOperations) RenameLinkArgsForCall(i int) (string, string) {
	fake.renameLinkMutex.RLock()
	defer fake.renameLinkMutex.RUnlock()
	argsForCall := fake.renameLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *LinkOperations) RenameLinkReturns(result1 error) {
	fake.renameLinkMutex.Lock()
	defer fake.renameLinkMutex.Unlock()
	fake.RenameLinkStub = nil
	fake.renameLinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) RenameLinkReturnsOnCall(i int, result1 error) {
	fake.renameLinkMutex.Lock()
	defer fake.renameLinkMutex.Unlock()
	fake.RenameLinkStub = nil
	if fake.renameLinkReturnsOnCall == nil {
		fake.renameLinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameLinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) RouteAddAll(arg1 []*types.Route, arg2 net.IP) error {
	var arg1Copy []*types.Route
	if arg1 != nil {
		arg1Copy = make([]*types.Route, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.routeAddAllMutex.Lock()
	ret, specificReturn := fake.routeAddAllReturnsOnCall[len(fake.routeAddAllArgsForCall)]
	fake.routeAddAllArgsForCall = append(fake.routeAddAllArgsForCall, struct {
		arg1 []*types.Route
		arg2 net.IP
	}{arg1Copy, arg2})
	stub := fake.RouteAddAllStub
	fakeReturns := fake.routeAddAllReturns
	fake.recordInvocation("RouteAddAll", []interface{}{arg1Copy, arg2})
	fake.routeAddAllMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) RouteAddAllCallCount() int {
	fake.routeAddAllMutex.RLock()
	defer fake.routeAddAllMutex.RUnlock()
	return len(fake.routeAddAllArgsForCall)
}

func (fake *LinkOperations) RouteAddAllCalls(stub func([]*types.Route, net.IP) error) {
	fake.routeAddAllMutex.Lock()
	defer fake.routeAddAllMutex.Unlock()
	fake.RouteAddAllStub = stub
}

func (fake *LinkOperations) RouteAddAllArgsForCall(i int) ([]*types.Route, net.IP) {
	fake.routeAddAllMutex.RLock()
	defer fake.routeAddAllMutex.RUnlock()
	argsForCall := fake.routeAddAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *LinkOperations) RouteAddAllReturns(result1 error) {
	fake.routeAddAllMutex.Lock()
	defer fake.routeAddAllMutex.Unlock()
	fake.RouteAddAllStub = nil
	fake.routeAddAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) RouteAddAllReturnsOnCall(i int, result1 error) {
	fake.routeAddAllMutex.Lock()
	defer fake.routeAddAllMutex.Unlock()
	fake.RouteAddAllStub = nil
	if fake.routeAddAllReturnsOnCall == nil {
		fake.routeAddAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.routeAddAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) SetPointToPointAddress(arg1 netlink.Link, arg2 net.IP, arg3 net.IP) error {
	fake.setPointToPointAddressMutex.Lock()
	ret, specificReturn := fake.setPointToPointAddressReturnsOnCall[len(fake.setPointToPointAddressArgsForCall)]
	fake.setPointToPointAddressArgsForCall = append(fake.setPointToPointAddressArgsForCall, struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.IP
	}{arg1, arg2, arg3})
	stub := fake.SetPointToPointAddressStub
	fakeReturns := fake.setPointToPointAddressReturns
	fake.recordInvocation("SetPointToPointAddress", []interface{}{arg1, arg2, arg3})
	fake.setPointToPointAddressMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) SetPointToPointAddressCallCount() int {
	fake.setPointToPointAddressMutex.RLock()
	defer fake.setPointToPointAddressMutex.RUnlock()
	return len(fake.setPointToPointAddressArgsForCall)
}

func (fake *LinkOperations) SetPointToPointAddressCalls(stub func(netlink.Link, net.IP, net.IP) error) {
	fake.setPointToPointAddressMutex.Lock()
	defer fake.setPointToPointAddressMutex.Unlock()
	fake.SetPointToPointAddressStub = stub
}

func (fake *LinkOperations) SetPointToPointAddressArgsForCall(i int) (netlink.Link, net.IP, net.IP) {
	fake.setPointToPointAddressMutex.RLock()
	defer fake.setPointToPointAddressMutex.RUnlock()
	argsForCall := fake.setPointToPointAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *LinkOperations) SetPointToPointAddressReturns(result1 error) {
	fake.setPointToPointAddressMutex.Lock()
	defer fake.setPointToPointAddressMutex.Unlock()
	fake.SetPointToPointAddressStub = nil
	fake.setPointToPointAddressReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) SetPointToPointAddressReturnsOnCall(i int, result1 error) {
	fake.setPointToPointAddressMutex.Lock()
	defer fake.setPointToPointAddressMutex.Unlock()
	fake.SetPointToPointAddressStub = nil
	if fake.setPointToPointAddressReturnsOnCall == nil {
		fake.setPointToPointAddressReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPointToPointAddressReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) StaticNeighborNoARP(arg1 netlink.Link, arg2 net.IP, arg3 net.HardwareAddr) error {
	fake.staticNeighborNoARPMutex.Lock()
	ret, specificReturn := fake.staticNeighborNoARPReturnsOnCall[len(fake.staticNeighborNoARPArgsForCall)]
	fake.staticNeighborNoARPArgsForCall = append(fake.staticNeighborNoARPArgsForCall, struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.HardwareAddr
	}{arg1, arg2, arg3})
	stub := fake.StaticNeighborNoARPStub
	fakeReturns := fake.staticNeighborNoARPReturns
	fake.recordInvocation("StaticNeighborNoARP", []interface{}{arg1, arg2, arg3})
	fake.staticNeighborNoARPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) StaticNeighborNoARPCallCount() int {
	fake.staticNeighborNoARPMutex.RLock()
	defer fake.staticNeighborNoARPMutex.RUnlock()
	return len(fake.staticNeighborNoARPArgsForCall)
}

func (fake *LinkOperations) StaticNeighborNoARPCalls(stub func(netlink.Link, net.IP, net.HardwareAddr) error) {
	fake.staticNeighborNoARPMutex.Lock()
	defer fake.staticNeighborNoARPMutex.Unlock()
	fake.StaticNeighborNoARPStub = stub
}

func (fake *LinkOperations) StaticNeighborNoARPArgsForCall(i int) (netlink.Link, net.IP, net.HardwareAddr) {
	fake.staticNeighborNoARPMutex.RLock()
	defer fake.staticNeighborNoARPMutex.RUnlock()
	argsForCall := fake.staticNeighborNoARPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *LinkOperations) StaticNeighborNoARPReturns(result1 error) {
	fake.staticNeighborNoARPMutex.Lock()
	defer fake.staticNeighborNoARPMutex.Unlock()
	fake.StaticNeighborNoARPStub = nil
	fake.staticNeighborNoARPReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) StaticNeighborNoARPReturnsOnCall(i int, result1 error) {
	fake.staticNeighborNoARPMutex.Lock()
	defer fake.staticNeighborNoARPMutex.Unlock()
	fake.StaticNeighborNoARPStub = nil
	if fake.staticNeighborNoARPReturnsOnCall == nil {
		fake.staticNeighborNoARPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.staticNeighborNoARPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteLinkByNameMutex.RLock()
	defer fake.deleteLinkByNameMutex.RUnlock()
	fake.disableIPv6Mutex.RLock()
	defer fake.disableIPv6Mutex.RUnlock()
	fake.enableIPv4ForwardingMutex.RLock()
	defer fake.enableIPv4ForwardingMutex.RUnlock()
	fake.enableReversePathFilteringMutex.RLock()
	defer fake.enableReversePathFilteringMutex.RUnlock()
	fake.renameLinkMutex.RLock()
	defer fake.renameLinkMutex.RUnlock()
	fake.routeAddAllMutex.RLock()
	defer fake.routeAddAllMutex.RUnlock()
	fake.setPointToPointAddressMutex.RLock()
	defer fake.setPointToPointAddressMutex.RUnlock()
	fake.staticNeighborNoARPMutex.RLock()
	defer fake.staticNeighborNoARPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *LinkOperations) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
